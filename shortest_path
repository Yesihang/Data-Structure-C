//---------------------------最短路径-----------------------------------------

//----数据结构
#define NUM 20
#define INFINITY 65535

typedef int elemtype;
typedef struct {
	elemtype vertex[NUM];
	int arc[NUM][NUM];
	int numnode, numedge; //顶点数，边数
}AMgraph;



//----算法代码（迪杰斯特拉算法）-----------------------------
typedef int Patharc[NUM];
typedef int PathTable[NUM];

void ShortestPath_Dijkstra(AMgraph G, int v0,Patharc* P, PathTable* D)
{
	int final[NUM];
	int i, j, h, min;

	for (i = 0; i < NUM;i++)
	{
		final[i] = 0;
		(*P)[i] = -1;
		(*D)[i] = G.arc[v0][i];
	}
	(*D)[v0] = 0;
	final[v0] = 1;

	for (i = 1; i < G.numnode; i++)
	{
		min = INFINITY;
		for (j = 0; j < G.numnode; j++)
		{
			if ((*D)[j] < min&&final[j] != 1)
			{
				min = (*D)[j];
				h = j;
			}
		}
		final[h] = 1;
		for (j = 0; j < G.numnode; j++)
		{
			if (final[j] != 1&&(min + G.arc[h][j]) < (*D)[j])
			{
				(*D)[j] = (min + G.arc[h][j]);
				(*P)[j] = h;
			}
		}
	}
}

//----算法代码（弗洛伊德算法）-----------------------------
typedef int Patharc[NUM][NUM];
typedef int PathTable[NUM][NUM];

void ShortestPath_Floyd(AMgraph G, Patharc* P, PathTable* D)
{
	int v, w, k;
	for(v=0;v<G.numnode;++v)
		for (w = 0; v < G.numnode; ++v)
		{
			(*P)[v][w] = w;
			(*D)[v][w] = G.arc[v][w];
		}
	for (k = 0; k < G.numnode; ++k)
		for (v = 0; v < G.numnode; ++v)
			for (w = 0; w < G.numnode; ++w)
			{
				if ((*D)[v][w] > (*D)[v][k] + (*D)[k][w])
				{
					(*D)[v][w] = (*D)[v][k] + (*D)[k][w];
					(*P)[v][w] = (*P)[v][k];
				}
			}
}

//----打印各顶点间最短路径
void PrintShortestPath(AMgraph G, Patharc* P, PathTable* D)
{
	int v, w,k;
	for (v = 0; v < G.numnode; ++v)
	{
		for (w = 0; w < G.numnode; ++w)
		{
			printf("v%d-v%d weight %d", v, w, (*D)[v][w]);
			k = (*P)[v][w];
			printf("Path:%d", v);
			while (k != w)
			{
				printf(" -> %d", k);
				k = (*D)[k][w];
			}
			printf(" -> %d\n", w);
		}
		printf("\n");
	}
}










